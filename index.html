<!DOCTYPE html>
<html>
<head>
	<title>js常用算法</title>
</head>
<body>
	<style type="text/css">

		* {margin:0;padding:9;}
		body {}
		pre {-webkit-font-smoothing:antialiased;font-size:14px;background:#f6f6f6;color:#333;padding:10px;}
		a {text-decoration:none;color:#333;}
		a:hover {border-bottom:2px solid #abcdef;}
		ul {}
		li {list-style: none;display: block;height:30px;line-height:30px;}
		li a {display:block;font-size:14px;text-align:left;}
		.container {margin:20px auto;}
		.left {width:20%;float:left;}
		.menu {}
		.right {width:75%;float:right;padding-left:5%;font-size:20px;}
		.box {display: none;}
		span {display:block;padding:20px;font-size:12px;color:red;}
		.show {display:block;}
		.active {border-bottom:2px solid #abcdef;}

		canvas {background:#000;}
		button{width:100px;height:30px;cursor:pointer;}

		p {font-size:12px;background:#abcdef;padding:10px;margin-bottom:10px;}
		

	</style>
<span>运行结果查看控制台</span>
	<div id="main" class="container">

		
		<div class="left">
			<div class="menu">
				<ul>
					<li class="active"><a href="javascript:void(0);">冒泡排序</a></li>
					<li><a href="javascript:void(0);">快速排序</a></li>
					<li><a href="javascript:void(0);">判断回文</a></li>
					<li><a href="javascript:void(0);">数组去重</a></li>
					<li><a href="javascript:void(0);">出现次数最多</a></li>
					<li><a href="javascript:void(0);">
						变量值交换
					</a></li>
					<li><a href="javascript:void(0);">
						生成斐波那契数组
					</a></li>
					<li><a href="javascript:void(0);">
						数组的最大差值
					</a></li>
					<li><a href="javascript:void(0);">
						随机生成字符串
					</a></li>
					<li><a href="javascript:void(0);">
						getElementsByClassName
					</a></li>
					<li><a href="javascript:void(0);">
						查找二叉树
					</a></li>
			
				</ul>
			</div>
		</div>

		<div class="right">
			<div class="box show">
				<p>冒泡排序就是依次比较大小之后在进行位置上的交换</p>
				<pre>
let bubbleSort = (arr) => {
  var i = 0,
      j = 0;
  for(i=1; i < arr.length; i++){
    for(j=0; j <= arr.length-i; j++){
      var temp = 0;
      // ">" 从小到大排序
      // "<" 从大到小排序
      if(arr[j] > arr[j+1]){
        temp = arr[j];
        arr[j] = arr[j+1];
        arr[j+1] = temp;
      }
    }
  }
  return arr;
}

var a1 = [3,5,2,61,235,291,23,112]

bubbleSort(a1);
				</pre>
				<button onclick="bubbleSort([3,5,2,61,235,291,23,112])">运行</button>
				
			</div>
			<div class="box">
				<p>快速排序就是参考某个元素的值，将小于它的值放到左数组，大于的放到右数组。<br />然后递归进行重复操作，最后合并两个数组</p>
				<pre>
let quickSort = (arr) => {

    if(arr.length<=1) {
        return arr;
    }

    let leftArr = [];
    let rightArr = [];
    let q = arr[0];
    for(let i = 1,l=arr.length; i < l; i++) {
        if(arr[i]>q) {
            rightArr.push(arr[i]);
        }else{
            leftArr.push(arr[i]);
        }
    }

    return [].concat(quickSort(leftArr),[q],quickSort(rightArr));
}

var a1 = [3,5,2,61,235,291,23,112]

quickSort(a1);
				</pre>
				<button onclick="quickSort([3,5,2,61,235,291,23,112])">运行</button>
				
			</div>
			<div class="box">
				<p>回文就是把相同的词汇或句子，调整位置之后还是原来的顺序</p>
				<pre>
let checkPalindrom = (str) => {  
    return str == str.split('').reverse().join('');
}

let str = 'mamam', str1 = 'redivider';

checkPalindrom(str);
checkPalindrom(str1);		
				</pre>
				<button onclick="checkPalindrom('mamam')">运行</button>
				
			</div>
			<div class="box">
				<p>利用key进行筛选</p>
				<pre>
let unique = (arr) => {  
  let hashTable = {};
  let data = [];
  for(let i=0,l=arr.length;i < l;i++) {
    if(!hashTable[arr[i]]) {
      hashTable[arr[i]] = true;
      data.push(arr[i]);
    }
  }
  return data
}

unique([1,13,24,11,11,14,1,2]);
				</pre>

				<button onclick="unique([1,13,24,11,11,14,1,2])">运行</button>
			</div>

			<div class="box">
				<p>统计重复次数</p>
				<pre>
let findMaxDuplicateChar = (str) => {  
  if(str.length == 1) {
    return str;
  }
  let charObj = {};
  for(let i=0;i < str.length;i++) {
    if(!charObj[str.charAt(i)]) {
      charObj[str.charAt(i)] = 1;
    }else{
      charObj[str.charAt(i)] += 1;
    }
  }
  let maxChar = '',
      maxValue = 1;
  for(var k in charObj) {
    if(charObj[k] >= maxValue) {
      maxChar = k;
      maxValue = charObj[k];
    }
  }
  return maxChar;

}

findMaxDuplicateChar('afjghdfraaaasdenas')

				</pre>
				<button onclick="findMaxDuplicateChar('afjghdfraaaasdenas')">运行</button>
			</div>

			<div class="box">
				<p>主要利用+-去进行运算，类似 a = a+(b-a);</p>
				<pre>
let swap = (a , b) => {  
  b = b - a;
  a = a + b;
  b = a - b;
  return [a,b];
}

swap(2, 4);	
				</pre>
				<button onclick="swap(2,4)">运行</button>
			</div>
			<div class="box">
				<p>又称黄金分割数列</p>
				<pre>
let getFibonacci = (n) => {  
  var fibarr = [];
  var i = 0;
  while(i< n) {
    if(i <= 1) {
      fibarr.push(i);
    }else{
      fibarr.push(fibarr[i-1] + fibarr[i-2])
    }
    i++;
  }

  return fibarr;
}

// 生成最大10个
getFibonacci(10);
				</pre>
				<button id="drawFib">运行</button>

				<canvas></canvas>
			</div>

			<div class="box">
				<p>最大值的查找，然后计算最大值和最小值的差值</p>
				<pre>
let getMaxProfit = (arr) => {

    var minPrice = arr[0];
    var maxProfit = 0;

    for (var i = 0; i < arr.length; i++) {
        var currentPrice = arr[i];

        minPrice = Math.min(minPrice, currentPrice);

        var potentialProfit = currentPrice - minPrice;

        maxProfit = Math.max(maxProfit, potentialProfit);
    }

    return maxProfit;
}

getMaxProfit([234,24,6,8,82,92]);
				</pre>
				<button onclick="getMaxProfit([234,24,6,8,82,92])">运行</button>
			</div>

			<div class="box">
				<pre>
let randomString = (n) => {  
  let str = 'abcdefghijklmnopqrstuvwxyz9876543210';
  let tmp = '',
      i = 0,
      l = str.length;
  for (i = 0; i < n; i++) {
    tmp += str.charAt(Math.floor(Math.random() * l));
  }
  return tmp;
}

randomString(23);		
				</pre>
				<button onclick="randomString(23)">运行</button>
			</div>
			<div class="box">
				<pre>
let queryClassName = (node, name) => {  
  var starts = '(^|[ \n\r\t\f])',
       ends = '([ \n\r\t\f]|$)';
  var array = [],
        regex = new RegExp(starts + name + ends),
        elements = node.getElementsByTagName("*"),
        length = elements.length,
        i = 0,
        element;

    while (i < length) {
        element = elements[i];
        if (regex.test(element.className)) {
            array.push(element);
        }

        i += 1;
    }

    return array;
}

queryClassName(document.getElementById('main'), 'box');

				</pre>
				<button onclick="queryClassName(document.getElementById('main'), 'box')">运行</button>
			</div>

			<div class="box">
				<pre>
class Node {  
  constructor(data, left, right) {
    this.data = data;
    this.left = left;
    this.right = right;
  }
}

class BinarySearchTree {

  constructor() {
    this.root = null;
  }

  insert(data) {
    let n = new Node(data, null, null);
    if (!this.root) {
      return this.root = n;
    }
    let currentNode = this.root;
    let parent = null;
    while (1) {
      parent = currentNode;
      if (data < currentNode.data) {
        currentNode = currentNode.left;
        if (currentNode === null) {
          parent.left = n;
          break;
        }
      } else {
        currentNode = currentNode.right;
        if (currentNode === null) {
          parent.right = n;
          break;
        }
      }
    }
  }

  remove(data) {
    this.root = this.removeNode(this.root, data)
  }

  removeNode(node, data) {
    if (node == null) {
      return null;
    }

    if (data == node.data) {
      // no children node
      if (node.left == null && node.right == null) {
        return null;
      }
      if (node.left == null) {
        return node.right;
      }
      if (node.right == null) {
        return node.left;
      }

      let getSmallest = function(node) {
        if(node.left === null && node.right == null) {
          return node;
        }
        if(node.left != null) {
          return node.left;
        }
        if(node.right !== null) {
          return getSmallest(node.right);
        }

      }
      let temNode = getSmallest(node.right);
      node.data = temNode.data;
      node.right = this.removeNode(temNode.right,temNode.data);
      return node;

    } else if (data < node.data) {
      node.left = this.removeNode(node.left,data);
      return node;
    } else {
      node.right = this.removeNode(node.right,data);
      return node;
    }
  }

  find(data) {
    var current = this.root;
    while (current != null) {
      if (data == current.data) {
        break;
      }
      if (data < current.data) {
        current = current.left;
      } else {
        current = current.right
      }
    }
    return current.data;
  }

}		
				</pre>
			</div>	
		</div>

	</div>


	


	<script type="text/javascript">

		// 兄弟元素节点
		let getSiblings = (ele) => {
			let a = [];
			let cld = ele.parentNode.children;
			for(let i=0;i<cld.length;i++) {
				if(cld[i] !== ele) a.push(cld[i]);
			}
			return a;
		}


		// 冒泡排序
		// http://math.hws.edu/eck/jsdemo/sortlab.html
		let bubbleSort = (arr) => {
		
			let tmp = 0;

			for(let i=1;i<arr.length;i++) {

				// console.log(`第一层：${i}次：`)

				for(let j=0;j<arr.length-i;j++) {

					// console.log(`第二层：${j}次：${arr[j]}`);
					// console.log(`${arr[j]}和${arr[j+1]}比`);

					if(arr[j] > arr[j+1]) {
						temp = arr[j];
						arr[j] = arr[j+1];
						arr[j+1] = temp;
					}

					// console.log(arr);

				}
			}

			console.log(arr);

			return arr;
		}


		// 快速排序
		let quickSort = (arr) => {
			if(arr.length <= 1) return arr;

			let lArr = [], rArr = [], q = arr[0];

			for(let i = 1; i < arr.length;i++) {
				if(arr[i] > q) {
					rArr.push(arr[i]);
				} else {
					lArr.push(arr[i]);
				}
			}

			// console.log(lArr);
			// console.log(rArr);

			arr = [].concat(quickSort(lArr), [q], quickSort(rArr));


			console.log(arr);

			return arr;

		}


		// 判断回文
		let checkPalindrom = (str) => {

			let b = str == str.split('').reverse().join('');

			console.log(b);
			return b;

		}

		// 去掉整型数组重复的值
		let unique = (arr) => {

			let hashTable = {}, data = [];
			for(let i=0;i<arr.length;i++) {
				if(!hashTable[arr[i]]) {
					hashTable[arr[i]] = true;
					data.push(arr[i]);
				}
			}

			console.log(data);

			return data;
		}

		// 统计一个字符串出现最多次数的字符
		let findMaxDuplicateChar = (str) => {

			if(str.length == 1) return str;

			let charObj = {};

			for(let i=0;i<str.length;i++) {
				if(!charObj[str.charAt(i)]) {
					charObj[str.charAt(i)] = 1;
				} else {
					charObj[str.charAt(i)] += 1;
				}
			}

			let maxChar = '', maxValue = 1;

			for(var k in charObj) {
				if(charObj[k] >= maxValue) {
					maxChar = k;
					maxValue = charObj[k];
				}
			}

			console.log(maxChar);

			return maxChar;

		}

		// 不借助其它变量，进行两个整数的值交换
		let swap = (a, b) => {
			b = b - a;
			a = a + b;
			b = a -b;

			console.log(a, b);
			return [a, b];
		}

		// 生成斐波那契数组
		let getFibonacci = (n) => {
			let fibarr = [];
			let i=0;

			while( i < n) {
				if(i<= 1) {
					fibarr.push(i);
				} else {
					fibarr.push(fibarr[i-1] + fibarr[i-2]);
				}
				i++;
			}


			return fibarr;
		}

		// 绘制图形
		let draw = (ctx, r, n, prevR) => {



				let coor = {
					x : 300,
					y : 240
				}

				if(n > 2) {
					switch(n %4) {
						case 0:
							coor.y = coor.y - 5 * prevR;
							coor.y = coor.y + 5 * r;
						break;
						case 1 :
					        coor.x = coor.x + 5 * prevR;
					        coor.x = coor.x - 5 * r;
				        break;
				      	case 2 :
					        coor.y = coor.y + 5 * prevR;
					        coor.y = coor.y - 5 * r;
				        break;
				      	case 3 :
					        coor.x = coor.x - 5 * prevR;
					        coor.x = coor.x + 5 * r;
				        break;
					}
				}

				ctx.beginPath();
				ctx.arc(coor.x, coor.y, 5*r, Math.PI*0.5*n,Math.PI*0.5*(n-1), true);

				if(n> 1) {
				  switch(n%4) {
				      case 0 :
				        ctx.moveTo(coor.x - 5*r,coor.y);
				        break;
				      case 1 :
				        ctx.moveTo(coor.x,coor.y + 5*r);
				        break;
				      case 2 :
				       ctx.moveTo(coor.x + 5*r,coor.y);
				        break;
				      case 3 :
				        ctx.moveTo(coor.x,coor.y-5*r);
				        break;
					}
				}

				ctx.lineWidth = 1;
				ctx.strokeStyle = '#fff';
				ctx.stroke();

				
		}

		// 绘制斐波那契图形
		let drawFibonacci = (ctx, data) => {


			for(var i=0;i < data.length;i++) {
				if(data[i] != 0) 
					draw(ctx, data[i], i, data[i-1]);

			}
		}


		// 找出数组的最大差值
		let getMaxProfit = (arr) => {

			let minPrice = arr[0];
			let maxProfit = 0;

			for(let i=0;i<arr.length;i++) {

				let currentPrice = arr[i];
				minProce = Math.min(minPrice, currentPrice);

				let potentialProfit = currentPrice - minPrice;
				maxProfit = Math.min(maxProfit, potentialProfit);

			}

			console.log(maxProfit);

			return maxProfit;

		}

		// 仿getElementByClassName();
		let queryClassName = (node, name) => {
			let starts = '(^|[ \n\r\t\f])',
				ends = '([ \n\r\t\f]|$)';

			let arr = [],
				regex = new RegExp(starts + name + ends),
				elements = node.getElementsByTagName('*'),
				length = elements.length,
				i=0,
				element;


				
			while(i < length) {
				element = elements[i];

				if(regex.test(element.className)) {
					arr.push(element);
				}

				i += 1;
			}

			console.log(arr);

			return arr;
		}


		// 随机生成指定长度的字符串
		let randomString = (n) => {
			let str = 'abcdefghijklmnopqrstuvwxyz9876543210';
			let tmp = '', i = 0; l = str.length;

			for(i=0;i<n;i++) {
				tmp += str.charAt(Math.floor(Math.random()*l));
			}

			console.log(tmp);

			return tmp;
		}
		
		window.onload = () => {

			let arr = [3,5,2,61,235,291,23,112];

			// quickSort(arr);

			// 绘制斐波那契图形

			let data = getFibonacci(10);
			let canvas = document.querySelector('canvas');
			canvas.width = 600;
			canvas.height = 480;

			let ctx = canvas.getContext('2d');


			let drawBtn = document.querySelector('#drawFib');

			drawBtn.onclick = () => {
				drawFibonacci(ctx, data);
			}

		

			


			let lis = document.querySelectorAll('li');
			let boxs = document.querySelectorAll('.box');

			for(let i=0;i<lis.length;i++) {

				let li = lis[i];
				let box = boxs[i];
				let sBox = getSiblings(box);
				let sLi = getSiblings(li);


				li.onclick = () => {
					for(let j =0;j<sBox.length;j++) {
						sLi[j].removeAttribute('class')
						sBox[j].style.display = 'none';
					}
					li.setAttribute('class','active');
					box.style.display = 'block';
				}

			}

		}


	</script>
	



</body>
</html>